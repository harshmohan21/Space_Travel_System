To check if an entire record (all columns) is a duplicate, you can modify the `CustomItemProcessor` to compare all relevant columns against the database records. This involves creating a query that checks for the existence of a record with the same values for each column.

Here's how you can achieve that:

1. **Update the CustomItemProcessor:**

```java
import org.springframework.batch.item.ItemProcessor;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.Map;

public class CustomItemProcessor implements ItemProcessor<Map<String, Object>, Map<String, Object>> {

    private final JdbcTemplate jdbcTemplate;
    private final String destTable;
    private final String[] columns;

    public CustomItemProcessor(JdbcTemplate jdbcTemplate, String destTable, String[] columns) {
        this.jdbcTemplate = jdbcTemplate;
        this.destTable = destTable;
        this.columns = columns;
    }

    @Override
    public Map<String, Object> process(Map<String, Object> item) throws Exception {
        StringBuilder queryBuilder = new StringBuilder("SELECT COUNT(*) FROM " + destTable + " WHERE ");
        Object[] params = new Object[columns.length];

        for (int i = 0; i < columns.length; i++) {
            queryBuilder.append(columns[i]).append(" = ? ");
            if (i < columns.length - 1) {
                queryBuilder.append("AND ");
            }
            params[i] = item.get(columns[i]);
        }

        int count = jdbcTemplate.queryForObject(queryBuilder.toString(), params, Integer.class);

        if (count > 0) {
            // Skip the record if it already exists
            return null;
        }

        // Process the record if it does not exist
        return item;
    }
}
```

2. **Update Your Step Configuration:**

Modify the step configuration to pass the columns to the `CustomItemProcessor`:

```java
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobScope;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;

@Bean
@JobScope
public Step step(JobRepository jobRepository,
                 PlatformTransactionManager transactionManager,
                 ItemReader<Map<String, Object>> reader,
                 ItemProcessor<Map<String, Object>, Map<String, Object>> processor,
                 ItemWriter<Map<String, Object>> writer,
                 JdbcTemplate jdbcTemplate,
                 @Value("#{jobParameters['SkipException']}") String skipException,
                 @Value("#{jobParameters['lineCount']}") long lineCount,
                 @Value("#{jobParameters['destTable']}") String destTable) {

    System.out.println("Skip data " + skipException);
    int chunkSize = (int) (lineCount / 100);
    boolean skip = Boolean.parseBoolean(skipException);
    double skipLim = lineCount * 0.05;
    int skipLimit = Math.min((int) skipLim, Integer.MAX_VALUE);

    String[] columns = {"column1", "column2", "column3"}; // Replace with your actual column names

    StepBuilder stepBuilder = new StepBuilder("jobStep", jobRepository);
    return stepBuilder.<Map<String, Object>, Map<String, Object>>chunk(chunkSize, transactionManager)
            .reader(reader)
            .processor(new CustomItemProcessor(jdbcTemplate, destTable, columns)) // Use the custom processor
            .writer(writer)
            .faultTolerant()
            .skip(FlatFileParseException.class)
            .skip(BadSqlGrammarException.class)
            .retry(FlatFileParseException.class)
            .skipLimit(skip ? skipLimit : 0)
            .listener(new CustomStepExecutionListener(destTable))
            .listener(new CustomChunkListener(destTable))
            .build();
}
```

3. **Ensure Required Beans and Dependencies:**

Make sure you have the required beans and dependencies in your Spring configuration:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;

@Configuration
public class BatchConfiguration {

    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/yourdatabase");
        dataSource.setUsername("yourusername");
        dataSource.setPassword("yourpassword");
        return dataSource;
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

By passing an array of column names to the `CustomItemProcessor`, you can dynamically build a query that checks if all column values match for a record. If the record exists, the processor returns `null`, effectively skipping the record during the batch processing.
