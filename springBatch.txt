To create a listener in your Spring Batch application that prints any exceptions encountered while parsing or writing data and specifies which record caused it, you can implement a custom `ItemReadListener`, `ItemWriteListener`, and `ItemProcessListener`.

Here's how to do it:

### 1. Implement Custom Listeners

#### CustomItemReadListener

This listener will handle exceptions during the reading phase.

```java
import org.springframework.batch.core.ItemReadListener;
import org.springframework.stereotype.Component;

@Component
public class CustomItemReadListener implements ItemReadListener<Person> {

    @Override
    public void beforeRead() {
        // Optional: Add logic before reading if needed
    }

    @Override
    public void afterRead(Person item) {
        // Optional: Add logic after reading if needed
    }

    @Override
    public void onReadError(Exception ex) {
        System.err.println("Exception encountered while reading: " + ex.getMessage());
    }
}
```

#### CustomItemWriteListener

This listener will handle exceptions during the writing phase.

```java
import org.springframework.batch.core.ItemWriteListener;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class CustomItemWriteListener implements ItemWriteListener<Person> {

    @Override
    public void beforeWrite(List<? extends Person> items) {
        // Optional: Add logic before writing if needed
    }

    @Override
    public void afterWrite(List<? extends Person> items) {
        // Optional: Add logic after writing if needed
    }

    @Override
    public void onWriteError(Exception ex, List<? extends Person> items) {
        System.err.println("Exception encountered while writing: " + ex.getMessage());
        System.err.println("Records causing the issue: " + items);
    }
}
```

#### CustomItemProcessListener

This listener will handle exceptions during the processing phase.

```java
import org.springframework.batch.core.ItemProcessListener;
import org.springframework.stereotype.Component;

@Component
public class CustomItemProcessListener implements ItemProcessListener<Person, Person> {

    @Override
    public void beforeProcess(Person item) {
        // Optional: Add logic before processing if needed
    }

    @Override
    public void afterProcess(Person item, Person result) {
        // Optional: Add logic after processing if needed
    }

    @Override
    public void onProcessError(Person item, Exception ex) {
        System.err.println("Exception encountered while processing: " + ex.getMessage());
        System.err.println("Record causing the issue: " + item);
    }
}
```

### 2. Register Listeners in Your Step Configuration

Register these listeners in your step configuration to ensure they are used during the batch process.

```java
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.Job;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Bean
    public Job importUserJob(JobBuilderFactory jobBuilderFactory, Step step1) {
        return jobBuilderFactory.get("importUserJob")
                .incrementer(new RunIdIncrementer())
                .flow(step1)
                .end()
                .build();
    }

    @Bean
    public Step step1(StepBuilderFactory stepBuilderFactory,
                      ItemReader<Person> reader,
                      ItemProcessor<Person, Person> processor,
                      ItemWriter<Person> writer,
                      PlatformTransactionManager transactionManager,
                      CustomItemReadListener readListener,
                      CustomItemWriteListener writeListener,
                      CustomItemProcessListener processListener) {

        return stepBuilderFactory.get("step1")
                .<Person, Person>chunk(10)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .transactionManager(transactionManager)
                .listener(readListener)
                .listener(writeListener)
                .listener(processListener)
                .faultTolerant()
                .retryLimit(3)
                .retry(Exception.class)
                .skipLimit(10)
                .skip(Exception.class)
                .build();
    }
}
```

### Explanation

1. **Custom Listeners**:
   - **CustomItemReadListener**: Logs any exceptions encountered during the reading phase.
   - **CustomItemWriteListener**: Logs any exceptions encountered during the writing phase and prints the records causing the issue.
   - **CustomItemProcessListener**: Logs any exceptions encountered during the processing phase and prints the record causing the issue.

2. **Step Configuration**:
   - Register the custom listeners in the step configuration using the `.listener` method.
   - Ensure fault tolerance by setting retry and skip limits.

By following these steps, you will have a Spring Batch application that logs exceptions encountered during the reading, processing, and writing phases, and specifies which records caused the exceptions. This can be extremely helpful for debugging and handling errors in your batch process.
