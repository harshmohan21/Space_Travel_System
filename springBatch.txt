import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.FileSystemResource;

import java.util.List;
import java.util.Map;

@Configuration
public class BatchConfig {

    @Bean
    @StepScope
    public FlatFileItemReader<Map<String, Object>> reader(
            @Value("#{jobParameters['fileName']}") String fileName,
            @Value("#{jobParameters['csvColumns']}") List<String> csvColumns,
            @Value("#{jobParameters['columnsToRead']}") List<String> columnsToRead,
            @Value("#{jobParameters['dbColumns']}") List<String> dbColumns) {

        return new FlatFileItemReaderBuilder<Map<String, Object>>()
                .name("customItemReader")
                .resource(new FileSystemResource(fileName))
                .lineMapper(lineMapper(csvColumns, columnsToRead, dbColumns))
                .build();
    }

    private LineMapper<Map<String, Object>> lineMapper(List<String> csvColumns, List<String> columnsToRead, List<String> dbColumns) {
        DefaultLineMapper<Map<String, Object>> lineMapper = new DefaultLineMapper<>();

        DelimitedLineTokenizer lineTokenizer = new DelimitedLineTokenizer();
        lineTokenizer.setDelimiter(",");
        lineTokenizer.setStrict(false);
        lineTokenizer.setNames(csvColumns.toArray(new String[0])); // Use all CSV columns for tokenizing

        lineMapper.setLineTokenizer(lineTokenizer);
        lineMapper.setFieldSetMapper(fieldSet -> {
            Map<String, Object> map = new HashMap<>();
            for (int i = 0; i < columnsToRead.size(); i++) {
                String columnToRead = columnsToRead.get(i);
                String dbColumn = dbColumns.get(i);
                map.put(dbColumn, readValue(fieldSet, columnToRead));
            }
            return map;
        });
        return lineMapper;
    }

    private Object readValue(FieldSet fieldSet, String column) {
        // Add additional checks for data type consistency if needed.
        try {
            return fieldSet.readInt(column);
        } catch (Exception e1) {
            try {
                return fieldSet.readDouble(column);
            } catch (Exception e2) {
                try {
                    return fieldSet.readBoolean(column);
                } catch (Exception e3) {
                    return fieldSet.readString(column);
                }
            }
        }
    }

    private void validateDataTypes(List<String> dataTypes) {
        List<String> validDataTypes = List.of("int", "double", "boolean", "string");
        for (String dataType : dataTypes) {
            if (!validDataTypes.contains(dataType.toLowerCase())) {
                throw new IllegalArgumentException("Invalid data type: " + dataType);
            }
        }
    }
}
