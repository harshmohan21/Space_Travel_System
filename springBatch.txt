Certainly! Here's how you can modify the `CustomItemProcessor` to use the `List<String>` columns and the provided processor method:

1. **Implement the CustomItemProcessor:**

```java
import org.springframework.batch.item.ItemProcessor;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;
import java.util.Map;

public class CustomItemProcessor implements ItemProcessor<Map<String, Object>, Map<String, Object>> {

    private final JdbcTemplate jdbcTemplate;
    private final String destTable;
    private final List<String> columns;

    public CustomItemProcessor(JdbcTemplate jdbcTemplate, String destTable, List<String> columns) {
        this.jdbcTemplate = jdbcTemplate;
        this.destTable = destTable;
        this.columns = columns;
    }

    @Override
    public Map<String, Object> process(Map<String, Object> item) throws Exception {
        StringBuilder queryBuilder = new StringBuilder("SELECT COUNT(*) FROM " + destTable + " WHERE ");
        Object[] params = new Object[columns.size()];

        for (int i = 0; i < columns.size(); i++) {
            queryBuilder.append(columns.get(i)).append(" = ? ");
            if (i < columns.size() - 1) {
                queryBuilder.append("AND ");
            }
            params[i] = item.get(columns.get(i));
        }

        int count = jdbcTemplate.queryForObject(queryBuilder.toString(), params, Integer.class);

        if (count > 0) {
            // Skip the record if it already exists
            return null;
        }

        // Process the record if it does not exist
        return item;
    }
}
```

2. **Modify the Processor Method to Use the CustomItemProcessor:**

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Component
public class BatchProcessorConfig {

    private final JdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;

    public BatchProcessorConfig(JdbcTemplate jdbcTemplate, ObjectMapper objectMapper) {
        this.jdbcTemplate = jdbcTemplate;
        this.objectMapper = objectMapper;
    }

    @Bean
    public ItemProcessor<Map<String, Object>, Map<String, Object>> itemProcessor(@Value("#{jobParameters}") Map<String, Object> jobParameters) throws Exception {
        System.out.println("inside itemProcessor");

        String input = (String) jobParameters.get("jsonFile");
        ObjectNode obj = (ObjectNode) objectMapper.readTree(input);
        JsonNode dbColumns = obj.get("dbColumns");

        List<String> columnNames = ListGen(dbColumns);
        String destTable = obj.get("destTable").asText();

        return new CustomItemProcessor(jdbcTemplate, destTable, columnNames);
    }

    private List<String> ListGen(JsonNode dbColumns) {
        List<String> columns = new ArrayList<>();
        dbColumns.forEach(column -> columns.add(column.asText()));
        return columns;
    }
}
```

3. **Update Your Step Configuration to Use the Custom Item Processor:**

```java
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobScope;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;

@Bean
@JobScope
public Step step(JobRepository jobRepository,
                 PlatformTransactionManager transactionManager,
                 ItemReader<Map<String, Object>> reader,
                 ItemProcessor<Map<String, Object>, Map<String, Object>> processor,
                 ItemWriter<Map<String, Object>> writer,
                 JdbcTemplate jdbcTemplate,
                 @Value("#{jobParameters['SkipException']}") String skipException,
                 @Value("#{jobParameters['lineCount']}") long lineCount,
                 @Value("#{jobParameters['destTable']}") String destTable) {

    System.out.println("Skip data " + skipException);
    int chunkSize = (int) (lineCount / 100);
    boolean skip = Boolean.parseBoolean(skipException);
    double skipLim = lineCount * 0.05;
    int skipLimit = Math.min((int) skipLim, Integer.MAX_VALUE);

    StepBuilder stepBuilder = new StepBuilder("jobStep", jobRepository);
    return stepBuilder.<Map<String, Object>, Map<String, Object>>chunk(chunkSize, transactionManager)
            .reader(reader)
            .processor(processor) // Use the custom processor
            .writer(writer)
            .faultTolerant()
            .skip(FlatFileParseException.class)
            .skip(BadSqlGrammarException.class)
            .retry(FlatFileParseException.class)
            .skipLimit(skip ? skipLimit : 0)
            .listener(new CustomStepExecutionListener(destTable))
            .listener(new CustomChunkListener(destTable))
            .build();
}
```

With these changes, your `CustomItemProcessor` will check for duplicate records based on all specified columns and skip any duplicates. The `itemProcessor` method in `BatchProcessorConfig` sets up the processor with the necessary parameters extracted from the job parameters.











import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.*;

import javax.sql.DataSource;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

@ExtendWith(MockitoExtension.class)
public class BatchConfigTest {

    @Mock
    private DataSource dataSource;

    @Mock
    private JdbcTemplate jdbcTemplate;

    @InjectMocks
    private BatchConfig batchConfig;

    private String destTable = "test_table";

    @Test
    public void testEnsureTableExistsAndIsEmpty() {
        doNothing().when(jdbcTemplate).execute(anyString());
        batchConfig.ensureTableExistsAndIsEmpty(jdbcTemplate, destTable);
        verify(jdbcTemplate, times(1)).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");
        verify(jdbcTemplate, times(1)).execute("TRUNCATE TABLE " + destTable);
    }

    @Test
    public void testBuildDynamicSql() {
        Map<String, Object> sampleItem = new HashMap<>();
        sampleItem.put("col1", "val1");
        sampleItem.put("col2", "val2");

        String expectedSql = "INSERT INTO " + destTable + " (col1, col2) VALUES (:col1, :col2)";
        String sql = batchConfig.buildDynamicSql(sampleItem, destTable);

        assertEquals(expectedSql, sql);
    }

    @Test
    public void testMapToSqlParameterSource() {
        Map<String, Object> item = new HashMap<>();
        item.put("col1", "val1");
        item.put("col2", 123);

        SqlParameterSource parameterSource = batchConfig.mapToSqlParameterSource(item);

        assertEquals("val1", parameterSource.getValue("col1"));
        assertEquals(123, parameterSource.getValue("col2"));
    }

    @Test
    public void testItemWriter() throws Exception {
        doNothing().when(jdbcTemplate).execute(anyString());
        Map<String, Object> jobParameters = new HashMap<>();
        jobParameters.put("dest_table", destTable);

        ItemWriter<Map<String, Object>> writer = batchConfig.itemWriter(dataSource, jdbcTemplate, destTable);

        List<Map<String, Object>> items = new ArrayList<>();
        Map<String, Object> item = new HashMap<>();
        item.put("col1", "val1");
        item.put("col2", 123);
        items.add(item);

        writer.write(items);

        verify(jdbcTemplate, times(1)).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");
        verify(jdbcTemplate, times(1)).execute("TRUNCATE TABLE " + destTable);
    }
}
