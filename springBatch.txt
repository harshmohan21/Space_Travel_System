To allow your Spring Batch job to be configured dynamically based on the input file provided, you can pass the file path as a job parameter. This approach will enable you to specify different files at runtime without hardcoding the file path in your configuration.

Here's how you can achieve this:

### 1. Modify `BatchConfig` to Use Job Parameters

Update your `BatchConfig` to read the file path from job parameters:

```java
package com.batch.example.config;

import com.batch.example.model.Product;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.FileSystemResource;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

import javax.sql.DataSource;

@Configuration
public class BatchConfig {

    @Bean
    public Job jobBean(JobRepository jobRepository,
                       JobCompletionNotificationImpl listener,
                       Step steps) {
        return new JobBuilder("job", jobRepository)
                .listener(listener)
                .start(steps)
                .build();
    }

    @Bean
    public Step steps(JobRepository jobRepository,
                      DataSourceTransactionManager transactionManager,
                      ItemReader<Product> reader,
                      ItemProcessor<Product, Product> processor,
                      ItemWriter<Product> writer) {
        return new StepBuilder("jobStep", jobRepository)
                .<Product, Product>chunk(5, transactionManager)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .build();
    }

    @Bean
    @StepScope
    public FlatFileItemReader<Product> reader(@Value("#{jobParameters['filePath']}") String filePath) {
        return new FlatFileItemReaderBuilder<Product>()
                .name("itemReader")
                .resource(new FileSystemResource(filePath))
                .delimited()
                .names("productId", "title", "description", "price", "discount")
                .targetType(Product.class)
                .build();
    }

    @Bean
    public ItemProcessor<Product, Product> itemProcessor() {
        return new CustomItemProcessor();
    }

    @Bean
    public ItemWriter<Product> itemWriter(DataSource dataSource) {
        return new JdbcBatchItemWriterBuilder<Product>()
                .sql("insert into products(product_id, title, description, price, discount, discounted_price) values (:productId, :title, :description, :price, :discount, :discountedPrice)")
                .dataSource(dataSource)
                .beanMapped()
                .build();
    }
}
```

### 2. Update Main Application Class to Accept File Path

Modify your main application class to accept a file path as an argument and pass it as a job parameter:

```java
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BatchApplication implements CommandLineRunner {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job job;

    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        if (args.length > 0) {
            String filePath = args[0];
            JobParameters jobParameters = new JobParametersBuilder()
                    .addString("filePath", filePath)
                    .addLong("time", System.currentTimeMillis())
                    .toJobParameters();

            jobLauncher.run(job, jobParameters);
        } else {
            System.out.println("Please provide the file path as a parameter.");
        }
    }
}
```

### Explanation

1. **`@StepScope` Annotation**:
   - The `@StepScope` annotation on the `reader` bean allows the bean to be initialized with job parameters at runtime. This is crucial for dynamically passing parameters like the file path.

2. **`@Value("#{jobParameters['filePath']}")`**:
   - This SpEL (Spring Expression Language) expression retrieves the `filePath` parameter from the job parameters passed at runtime.

3. **Main Application Class**:
   - The `run` method now checks if a file path argument is provided. If so, it creates job parameters with the file path and a unique timestamp (to ensure a unique job instance) and launches the job with these parameters.

### Running the Application

You can now run your Spring Boot application with the file path as a command-line argument:

```sh
mvn spring-boot:run -Dspring-boot.run.arguments="path/to/your/data.csv"
```

This approach ensures that your batch job can process different files based on the input provided at runtime, making your application more flexible and dynamic.
