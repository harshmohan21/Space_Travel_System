import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.batch.core.JobParameters;
import org.springframework.jdbc.core.JdbcTemplate;

class JobParamTest {

    @Mock
    private JdbcTemplate jdbcTemplate;

    @InjectMocks
    private JobParam jobParam;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testSetJobParamSuccess() throws Exception {
        String tableName = "file_config";
        String configId = "1";
        String destTable = "dest_table";
        String filePath = "src/test/resources/testfile.csv";
        
        ConfigAccess configAccess = mock(ConfigAccess.class);
        Map<String, Object> config = new HashMap<>();
        config.put("FILEPATH", filePath);
        config.put("DELIMITER", ",");
        config.put("DEST_TABLE", destTable);
        config.put("lines_to_skip", 1);
        config.put("SKIP_EXCEPTION", "Y");
        config.put("APPEND_DATA", "N");
        config.put("FILE_COLUMNS", new String[] {"col1", "col2"});
        config.put("REQUIRED_COLUMNS", new String[] {"col1"});
        config.put("DB_COLUMNS", new String[] {"db_col1", "db_col2"});
        config.put("DATATYPES", new String[] {"String", "Integer"});

        when(configAccess.dao(tableName, configId)).thenReturn(config);
        when(jdbcTemplate.execute(anyString())).thenReturn(true);
        when(Files.lines(any(Path.class))).thenReturn(java.util.stream.Stream.of("line1", "line2"));

        JobParameters jobParameters = jobParam.setJobParam(tableName, configId);
        assertNotNull(jobParameters);
        assertEquals(filePath, jobParameters.getString("filePath"));
    }

    @Test
    void testSetJobParamFileConfigTableNotExist() {
        String tableName = "file_config";
        String configId = "1";

        doThrow(new RuntimeException("Table not found")).when(jdbcTemplate).execute("SELECT 1 FROM " + tableName + " WHERE 1 = 0");

        Exception exception = assertThrows(Exception.class, () -> {
            jobParam.setJobParam(tableName, configId);
        });

        assertEquals("File Configuration table doesn't exist", exception.getMessage());
    }

@Test
    void testSetJobParamDestTableNotExist() {
        String tableName = "file_config";
        String configId = "1";
        String destTable = "dest_table";
        String filePath = "src/test/resources/testfile.csv";

        // Mocking the configAccess to return a valid configuration
        Map<String, Object> config = new HashMap<>();
        config.put("FILEPATH", filePath);
        config.put("DELIMITER", ",");
        config.put("DEST_TABLE", destTable);
        config.put("lines_to_skip", 1);
        config.put("SKIP_EXCEPTION", "Y");
        config.put("APPEND_DATA", "N");
        config.put("FILE_COLUMNS", new String[] {"col1", "col2"});
        config.put("REQUIRED_COLUMNS", new String[] {"col1"});
        config.put("DB_COLUMNS", new String[] {"db_col1", "db_col2"});
        config.put("DATATYPES", new String[] {"String", "Integer"});

        when(configAccess.dao(tableName, configId)).thenReturn(config);

        // Mocking JdbcTemplate to simulate table existence check
        doNothing().when(jdbcTemplate).execute("SELECT 1 FROM " + tableName + " WHERE 1 = 0");
        doThrow(new RuntimeException("Table not found")).when(jdbcTemplate).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");

        Exception exception = assertThrows(Exception.class, () -> {
            jobParam.setJobParam(tableName, configId);
        });

        assertEquals("Destination table doesn't exist in database", exception.getMessage());
    }


    @Test
    void testValidateSkipAppendInvalidSkip() {
        Exception exception = assertThrows(IllegalArgumentException.class, () -> {
            JobParam.validateSkipAppend("invalid", "Y");
        });

        assertEquals("Invalid skip value: invalid", exception.getMessage());
    }

    @Test
    void testValidateSkipAppendInvalidAppend() {
        Exception exception = assertThrows(IllegalArgumentException.class, () -> {
            JobParam.validateSkipAppend("Y", "invalid");
        });

        assertEquals("Invalid append value: invalid", exception.getMessage());
    }

    @Test
    void testValidateDataTypesInvalidDataType() {
        Exception exception = assertThrows(IllegalArgumentException.class, () -> {
            JobParam.validateDataTypes(new Object[] {"String", "InvalidType"});
        });

        assertEquals("Invalid data type: InvalidType", exception.getMessage());
    }
}








<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4</artifactId>
    <version>2.0.9</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito2</artifactId>
    <version>2.0.9</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4-rule</artifactId>
    <version>2.0.9</version>
    <scope>test</scope>
</dependency>

