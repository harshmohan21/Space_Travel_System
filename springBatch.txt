To print the statistics after every write operation, you can implement a custom `ItemWriteListener`. This listener will log the required metrics after each write operation.

### Step 1: Create the `CustomItemWriteListener`

```java
import org.springframework.batch.core.ItemWriteListener;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.StepSynchronizationManager;

import java.util.List;
import java.util.Map;

public class CustomItemWriteListener implements ItemWriteListener<Map<String, Object>> {

    private final String destTable;

    public CustomItemWriteListener(String destTable) {
        this.destTable = destTable;
    }

    @Override
    public void beforeWrite(List<? extends Map<String, Object>> items) {
        // You can add any setup logic here if needed
    }

    @Override
    public void afterWrite(List<? extends Map<String, Object>> items) {
        StepExecution stepExecution = StepSynchronizationManager.getContext().getStepExecution();
        long readCount = stepExecution.getReadCount();
        long writeCount = stepExecution.getWriteCount();
        long skipCount = stepExecution.getSkipCount();

        System.out.println("Destination Table: " + destTable);
        System.out.println("Total records read: " + readCount);
        System.out.println("Total records written: " + writeCount);
        System.out.println("Total records skipped: " + skipCount);
    }

    @Override
    public void onWriteError(Exception exception, List<? extends Map<String, Object>> items) {
        // You can add error handling logic here if needed
    }
}
```

### Step 2: Register the Listener in Your Step Configuration

```java
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobScope;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.transaction.PlatformTransactionManager;

@Bean
@JobScope
public Step step(JobRepository jobRepository,
                 PlatformTransactionManager transactionManager,
                 ItemReader<Map<String, Object>> reader,
                 ItemProcessor<Map<String, Object>, Map<String, Object>> processor,
                 ItemWriter<Map<String, Object>> writer,
                 @Value("#{jobParameters['SkipException']}") String skipException,
                 @Value("#{jobParameters['lineCount']}") long lineCount,
                 @Value("#{jobParameters['destTable']}") String destTable) {

    System.out.println("Skip data " + skipException);
    int chunkSize = (int) (lineCount / 100);
    boolean skip = Boolean.parseBoolean(skipException);
    double skipLim = lineCount * 0.05;
    int skipLimit = Math.min((int) skipLim, Integer.MAX_VALUE);

    StepBuilder stepBuilder = new StepBuilder("jobStep", jobRepository);
    return stepBuilder.<Map<String, Object>, Map<String, Object>>chunk(chunkSize, transactionManager)
            .reader(reader)
            .processor(processor)
            .writer(writer)
            .faultTolerant()
            .skip(FlatFileParseException.class)
            .skip(BadSqlGrammarException.class)
            .retry(FlatFileParseException.class)
            .skipLimit(skip ? skipLimit : 0)
            .listener(new CustomItemWriteListener(destTable))
            .build();
}
```

### Explanation:

1. **CustomItemWriteListener**: This class implements the `ItemWriteListener` interface and provides the `afterWrite` method to log the desired metrics after each write operation.
2. **Step Configuration**: The `listener` method in the `StepBuilder` registers the `CustomItemWriteListener` to the step.

With this setup, your application will print the statistics after every write operation, giving you real-time updates on the number of records processed.
