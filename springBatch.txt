import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.configuration.annotation.JobScope;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Configuration
public class BatchConfiguration {

    @Bean
    @JobScope
    public FlatFileItemReader<Map<String, Object>> reader(@Value("#{jobParameters['inputFile']}") String inputFile) {
        return new FlatFileItemReaderBuilder<Map<String, Object>>()
                .name("mapItemReader")
                .resource(new ClassPathResource(inputFile))
                .delimited()
                .names(new String[]{"column1", "column2", "column3"}) // Example columns, replace with actual columns
                .fieldSetMapper(fieldSet -> {
                    Map<String, Object> map = new HashMap<>();
                    for (String name : fieldSet.getNames()) {
                        map.put(name, fieldSet.readString(name));
                    }
                    return map;
                })
                .build();
    }

    @Bean
    @JobScope
    public ItemWriter<Map<String, Object>> itemWriter(DataSource dataSource, 
                                                      JdbcTemplate jdbcTemplate, 
                                                      @Value("#{jobParameters['tableName']}") String tableName) {
        System.out.println("inside itemWriter: " + dataSource + " for table: " + tableName);

        // Ensure the table exists and is empty
        ensureTableExistsAndIsEmpty(jdbcTemplate, tableName);

        return items -> {
            if (items.isEmpty()) {
                return; // No items to write
            }

            // Get the keys from the first item to build the SQL statement
            Map<String, Object> sampleItem = items.iterator().next();
            String sql = buildDynamicSql(sampleItem, tableName);

            JdbcBatchItemWriter<Map<String, Object>> writer = new JdbcBatchItemWriterBuilder<Map<String, Object>>()
                .itemSqlParameterSourceProvider(this::mapToSqlParameterSource)
                .sql(sql)
                .dataSource(dataSource)
                .build();

            // Open the writer (necessary because we are manually constructing it)
            writer.afterPropertiesSet();
            
            // Write the items
            writer.write(items);
        };
    }

    private void ensureTableExistsAndIsEmpty(JdbcTemplate jdbcTemplate, String tableName) {
        String createTableSql = "CREATE TABLE IF NOT EXISTS " + tableName + " ("
                + "id INT AUTO_INCREMENT PRIMARY KEY, "
                + "title VARCHAR(255), "
                + "description TEXT, "
                + "price DECIMAL(10, 2), "
                + "discount DECIMAL(5, 2), "
                + "discounted_price DECIMAL(10, 2))";

        String truncateTableSql = "TRUNCATE TABLE " + tableName;

        jdbcTemplate.execute(createTableSql);
        jdbcTemplate.execute(truncateTableSql);
    }

    private String buildDynamicSql(Map<String, Object> sampleItem, String tableName) {
        String columns = String.join(", ", sampleItem.keySet());
        String placeholders = sampleItem.keySet().stream()
            .map(key -> ":" + key)
            .collect(Collectors.joining(", "));

        return "INSERT INTO " + tableName + " (" + columns + ") VALUES (" + placeholders + ")";
    }

    private SqlParameterSource mapToSqlParameterSource(Map<String, Object> item) {
        MapSqlParameterSource parameterSource = new MapSqlParameterSource();
        item.forEach(parameterSource::addValue);
        return parameterSource;
    }

    // Other beans for job, steps, reader, and processor can be defined here
}
