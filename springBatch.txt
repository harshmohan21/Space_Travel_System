import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;

import javax.sql.DataSource;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CustomItemWriterTest {

    @Mock
    private DataSource dataSource;

    @Mock
    private JdbcTemplate jdbcTemplate;

    private CustomItemWriter customItemWriter;

    private final String destTable = "test_table";
    private final String appendData = "n";

    @BeforeEach
    void setUp() {
        customItemWriter = new CustomItemWriter(dataSource, jdbcTemplate, destTable, appendData);
    }
@Test
    void testEnsureTableExists_TableExists() {
        // Mock the JdbcTemplate to do nothing when execute is called with the expected SQL
        doNothing().when(jdbcTemplate).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");

        // Call the method and assert that no exception is thrown
        assertDoesNotThrow(() -> customItemWriter.ensureTableExists(jdbcTemplate, destTable));

        // Verify that execute was called once with the expected SQL
        verify(jdbcTemplate, times(1)).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");
    }

    @Test
    void testEnsureTableExists_TableDoesNotExist() {
        // Mock the JdbcTemplate to throw an exception when execute is called with the expected SQL
        doThrow(new RuntimeException("Table does not exist")).when(jdbcTemplate).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");

        // Call the method and assert that a RuntimeException is thrown with the expected message
        Exception exception = assertThrows(RuntimeException.class, () -> {
            customItemWriter.ensureTableExists(jdbcTemplate, destTable);
        });

        // Verify that the exception message contains the expected text
        assertTrue(exception.getMessage().contains("Table " + destTable + " does not exist"));

        // Verify that execute was called once with the expected SQL
        verify(jdbcTemplate, times(1)).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");
    }
    @Test
    void testEnsureTableExistsAndIsEmpty_TableExistsAndIsEmptied() {
        doNothing().when(jdbcTemplate).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");
        doNothing().when(jdbcTemplate).execute("TRUNCATE TABLE " + destTable);

        assertDoesNotThrow(() -> customItemWriter.ensureTableExistsAndIsEmpty(jdbcTemplate, destTable));

        verify(jdbcTemplate, times(1)).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 0");
        verify(jdbcTemplate, times(1)).execute("TRUNCATE TABLE " + destTable);
    }
    @Test
    void testEnsureTableExistsAndIsEmpty_TableDoesNotExist() {
        doThrow(new RuntimeException("Table does not exist")).when(jdbcTemplate).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 1");

        Exception exception = assertThrows(RuntimeException.class, () -> {
            customItemWriter.ensureTableExistsAndIsEmpty(jdbcTemplate, destTable);
        });

        assertTrue(exception.getMessage().contains("Table " + destTable + " does not exist"));
    }

    @Test
    void testEnsureTableExistsAndIsEmpty_TableNotEmptied() {
        doNothing().when(jdbcTemplate).execute("SELECT 1 FROM " + destTable + " WHERE 1 = 1");
        doThrow(new RuntimeException("Failed to empty table")).when(jdbcTemplate).execute("TRUNCATE TABLE " + destTable);

        Exception exception = assertThrows(RuntimeException.class, () -> {
            customItemWriter.ensureTableExistsAndIsEmpty(jdbcTemplate, destTable);
        });

        assertTrue(exception.getMessage().contains("Failed to empty table " + destTable));
    }

    @Test
    void testWrite_ItemsWrittenSuccessfully() throws Exception {
        Map<String, Object> item1 = new HashMap<>();
        item1.put("column1", "value1");
        item1.put("column2", "value2");

        List<Map<String, Object>> items = Collections.singletonList(item1);

        SimpleJdbcInsert writer = mock(SimpleJdbcInsert.class);
        when(writer.executeBatch(any(SqlParameterSource[].class))).thenReturn(new int[]{1});

        ReflectionTestUtils.setField(customItemWriter, "writer", writer);

        customItemWriter.write(items);

        verify(writer, times(1)).executeBatch(any(SqlParameterSource[].class));
    }

    @Test
    void testWrite_NoItemsToWrite() throws Exception {
        List<Map<String, Object>> items = Collections.emptyList();

        customItemWriter.write(items);

        verifyNoInteractions(dataSource);
    }

    @Test
    void testBuildDynamicSql() {
        Map<String, Object> sampleItem = new HashMap<>();
        sampleItem.put("column1", "value1");
        sampleItem.put("column2", "value2");

        String sql = customItemWriter.buildDynamicSql(sampleItem, destTable);

        assertEquals("INSERT INTO " + destTable + " (column1, column2) VALUES (:column1, :column2)", sql);
    }

    @Test
    void testMapToSqlParameterSource() {
        Map<String, Object> item = new HashMap<>();
        item.put("column1", "value1");
        item.put("column2", "value2");

        SqlParameterSource parameterSource = customItemWriter.mapToSqlParameterSource(item);

        assertTrue(parameterSource instanceof MapSqlParameterSource);
        assertEquals("value1", ((MapSqlParameterSource) parameterSource).getValue("column1"));
        assertEquals("value2", ((MapSqlParameterSource) parameterSource).getValue("column2"));
    }
}
